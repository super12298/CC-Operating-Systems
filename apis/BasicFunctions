--Basic Functions API 
-----------------------------------
--Config (nul or blank == off and 1 == on)
debug = nul
-----------------------------------
--All Functions
-----------------------------------
--Reboot with a countdown!
--Hint default is (1,18)
--usage BFS.sdc(x,y)

--Downloads Files from any source
--usage BFS.df("url", "path")

--Makes directory
--usage BFS.md("path")

--Detects Rednet and turns it on("true") or off("false")
--usage BFS.rd("true")

--This function draws a image
--usage BFS.dg("path", sleeptimeinseconds)

--This function prints the content of a page
--usage BFS.getlog("path")

--OS function that updates the system
--Usage BFS.verc("versionpath", "versionurl", "updatelocation", "updateurl")

--Disables or Enables the disk startup.
--usage BFS.DiskS("false") or BFS.DiskS("true")

--[Advance] Downloads Files from any source
--usage BFS.dfa("url", "backupurl", "path")

--Displays the computer label and id
--Usage BFS.dply(5,8)
-----------------------------------
local nTime = os.time()
local nDay = os.day()
local nID = os.getComputerID()
local nLabel = os.getComputerLabel()
local nOS = os.version()
local COS = {"CraftOS 1.8", "CraftOS 1.7", "CraftOS 1.6", "CraftOS 1.5", "CraftOS 1.4", "CraftOS 1.3", "CraftOS 1.2", "CraftOS 1.1", "CraftOS 1.0"}

--This is a test function
function cdwn()
rn = 8
for i=1,rn do
print(rn)
rn = rn-1
end
end

if not debug then
os.pullEvent = os.pullEventRaw
sleep(.3)
end

--Reboot with a countdown!
--usage BFS.sdc(x,y)
function sdc(x,y)
timer = 5
	for i=1,timer do
		term.setCursorPos(x,y)
		print("Rebooting in "..timer.."...")
		sleep(1)
	timer = timer-1
end
os.reboot()
end


--Downloads Files from any source
--usage BFS.df("url", "path")
function df(url, path, wdl)
local check, msg = http.checkURL(url)
if not check then
write("Invalid URL: Error[" .. msg.."]")
else
if path == nul or path == "" or path == "/" then
write("Invalid Path")
else
	for i = 1, 3 do
	local response = http.get(url)
		if response then
		local data = response.readAll()
				if path then
				local f = io.open(path, "w")
				--print(url, wdl)
				sleep(.1)
				if wdl then
				f:write(wdl.."\n")
				end
				f:write(data)
				f:close()
				end
			return true
			end
		end
	return false
end
end
end

--[Advance] Downloads Files from any source
--usage BFS.dfa("url", "backupurl", "path")
function dfa(original, backup, path)
local ch3ck, msag = http.checkURL(original)
if not fs.exists(path) then
if ch3ck then
df(original, path)
else
df(backup, path)
end
end
end

local function getDeviceSide(deviceType)
  local lstSides = {"left","right","up","down","front","back"};
  for i, side in pairs(lstSides) do
    if (peripheral.isPresent(side)) then
      if (peripheral.getType(side) == string.lower(deviceType)) then
        return side;
      end
    end
  end
  return nil;
end

--Makes directory
--usage BFS.md(directory you want to make)
function md(dir)
	if not fs.exists(dir) then
	fs.makeDir(dir)
	else
	--print(dir.." already exist!")
	end
end 

--Detects Rednet and turns it on("true") or off("false")
--usage BFS.rd("true")
function rd(quest)
if nOS == COS[3] or nOS == COS[4] then

else
modemSide = getDeviceSide("modem")
	if quest == "true" then
		if (modemSide) then
		rednet.open(modemSide)
		end
	else
	rednet.close(modemSide)
	end
end
end

--This function draws a image
--usage BFS.dg("path", sleeptimeinseconds)
function dg(path, speed)
if term.isColor() then
BGL = paintutils.loadImage(path) 
paintutils.drawImage(BGL,1,1)
else
local pic = fs.open(path, "r")
local pic2 = pic.readAll()
term.clear()
term.setCursorPos(1,1)
--print(pic2)
pic.close()
end
sleep(speed)
end

--This Function prints the content of a page
--usage BFS.getlog("path")
function getlog(path)
local log = http.get(path) --Get contents of page
local log2 = log.readAll()
print(log2)
end

--OS function that updates the system
--Usage BFS.verc("versionpath", "versionurl", "updatelocation", "updateurl")
function verc(path, url, updl, updp, word)
http.request(url)
local requesting = true
local event, url, sourceText = os.pullEvent()
 if event == "http_success" then
	if not fs.exists(path) or not fs.exists(updl)then
	df(updp, updl, word)
	df(url, path)
	os.run({},updl)
	--fs.delete(updl)
	print("Successfully updated!")	
	else
	local vnid = http.get(url)
	local rvnid = vnid.readAll()
		if fs.exists(path) then
		local readvn = fs.open(path, "r")
		local readvern = readvn.readAll()
		readvn.close()
		vn = readvern
			if vn == rvnid then
			--fs.delete(updl)
			print("The software on this computer is up to date.")
			else
			df(updp, updl)
			df(url, path)
			os.run({},updl)
			--fs.delete(updl)
			print("Successfully updated!")	
			end
		end
	end

elseif event == "http_failure" then
print("404 Page Not Found")
end
end

--Disables or Enables the disk startup.
--usage BFS.DiskS("false") or BFS.DiskS("true")
function DiskS(quest)
if nOS == COS[3] or nOS == COS[4] then
print("["..nOS.."]: Compatibility mode activated.")
sleep(.3)
else
bootFromDisk = settings.get("shell.allow_disk_startup", "not set")
print(bootFromDisk)
if bootFromDisk == true then
settings.set("shell.allow_disk_startup", quest)
settings.save(".settings")
end
end
end

--Compairs the udid nothing special.
function Comp_udid(path, errorimg)
if fs.exists(path) then
	local fr = fs.open(path, "r")
	udid1 = fr.readAll()
	if fs.exists(path..".ref") then
		local gf = fs.open(path..".ref", "r")
		udid2 = gf.readAll()	
	else		
	udid2 = "NONE"
	end
 	test = udid1
	if udid1 == udid2 then
	else
	dg(errorimg, 0)
		term.setCursorPos(1,1)
	print("[Error]")
	sleep(10)
	os.reboot()
	end
	fr.close()
	--gf.close()
	end
end

--Generates a unique id for the computer (You can use this to make a unique rednet id) and will check (if you put true) if it has been tampered it will prevent the computer from booting.
--  change 'compair' to true or false
--Usage BFS.udid("Codename", "path", "Compair". )
function udid(name, path)
	if not fs.exists(path) then
	local f = io.open(path, "w")
	f:write(name)
		for i = 1, 25 do
		local items = {"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9"}
		f:write(items[math.random(1, #items)])
		end
	f:close()
	if fs.exists(path..".ref") then
	os.reboot()
	else
	fs.copy(path, path..".ref")
	end
	end
end
--Displays the computer label and id
--Usage BFS.dply(5,8)
function dply(x,y)
	term.setCursorPos(x,y)
	if nLabel then
	print("Computer:"..nLabel..","..nID)
	else
	print("Computer: [N/A],"..nID)
	end
end

--Text with location
--Usage BFS.tpla(5,8,txt)
function tpla(x,y,txt)
	term.setCursorPos(x,y)
	print(txt)
end

--read file and prints it to a location
--Usage   readfile(1,4,/some/file/data)
function readfile(x,y,file)
term.setCursorPos(x,y)
local readfl = fs.open(file, "r")
readallfl = readfl.readAll()
readfl.close()
print(readallfl)
end

--used for change log 'slow' or 'fast'
--function BFS.chlog("url","slow")
function chlog(url,printsp)
success, message = http.get(url)
if success then
datard1 = http.get(url)
datard2 = datard1.readAll()
if printsp =="fast" then
print(datard2)
elseif printsp =="slow" then
textutils.slowPrint(datard2)
else
error("Incorrect format. \n[Usage]:\nBFS.chlog('url','slow') \nBFS.chlog('url','fast') ")
end
else
print("404 Page not found.")
end
end

--compares HTML and file
--Usage BFS.chaf(url, path)
function chaf(url, path)
	local vnid = http.get(url)
	local rvnid = vnid.readAll()
		if fs.exists(path) then
		local readvn = fs.open(path, "r")
		local readvern = readvn.readAll()
		readvn.close()
		vn = readvern
			if vn == rvnid then
			print(path.."...OK")
			sleep(.1)
			else
			df(url, path)
			print(path.." has been updated!")
			sleep(.1)
			end
		end
end

--sets a label
--Usage BFS.setl("Comp_2")
function setl(name)
if os.getComputerLabel() == nul then
os.setComputerLabel(name)
end
end

--reads a file or website and turns it into a table
--Usage BFS.rwf("File location or website url", "file") <-- put the word |"file" or "f"| or |"website" or "w"|
function rwf(fw, worf)
if worf == "website" or worf == "w" then
readfw = http.get(fw)
elseif worf == "file" or worf == "f" then
readfw = fs.open( fw, "r" )
else
error("")
end

lines = {}
for line in readfw.readLine do
    lines[#lines+1] = line
end
readfw.close()
end

--prints a line from file or website
--Usage BFS.printline(#)
function printline(n)
print(lines[n])
end

--Downloads using a line from file or website(1). The second number is the location(2).
--Usage BFS.printline(#, #)
function downloadurl(n, l)
usage BFS.df(lines[n], lines[l])
end
